<resources>
    <string name="app_name">Algorithm Simulator</string>
    <string name="algorithms">Algorithms</string>
    <string name="textview">TextView</string>
    <string name="image_of_animal">image of animal</string>
    <string name="baboon">Baboon</string>
    <string name="description">description</string>
    <string name="todo">TODO</string>
    <!-- activity names -->
    <string name="bubble_sort">Bubble Sort</string>
    <string name="insertion_sort">Insertion Sort</string>
    <string name="heap_sort">Heap Sort</string>
    <string name="array">Array</string>
    <string name="queue">Queue</string>
    <string name="stack">Stack</string>
    <string name="list">Lists</string>
    <string name="mergeSort">Merge Sort</string>
    <string name="linearSearch">Linear Search</string>
    <string name="BinarySearch">Binary Search</string>
    <string name="heap">Heap</string>
    <string name="bst">Binary Search Tree</string>
    <!-- Buttons name -->
    <string name="next_bu">next_bu</string>
    <string name="pre_bu">pre_bu</string>
    <string name="next">Next</string>
    <string name="pre">Pre</string>
    <string name="reset">Reset</string>
    <string name="Auto">Auto</string>
    <string name="simulator">simulator</string>
    <string name="study">study</string>
    <string name="button">button</string>
    <string name="title_activity_welcome_screen">welcome_screen</string>
    <string name="copy_right" translatable="false">Copyrights Â© %1$d</string>


    <!--strings for busort -->
    <string name="busort1">Bubble sort is a sorting algorithm used to sort a sequence of numbers</string>
    <string name="busort2">The scale at the right end of the sequence will compare the number on their left and right
        sides.
    </string>
    <string name="busort3">In this case, they will compare 8 and 2</string>
    <string name="busort4">After comparing them, if the number on the right is found to be smaller, the number will be
        swapped.
    </string>
    <string name="busort5">8 is greater than 2 so the numbers do not get swapped.</string>
    <string name="busort6">After the comparison is finished, the scale move one position to the left.</string>
    <string name="busort7">Numbers are compared once again.</string>
    <string name="busort8">This time 2 is smaller than 7 so the numbers get swapped.</string>
    <string name="busort9">The scale move one position to left.</string>
    <string name="busort10">This operation is repeated untill the scale reach the left end of the sequence</string>
    <string name="busort11">The number on the left edge is considered fully sorted.</string>
    <string name="busort12">and the scale is moved back to the right edge.</string>
    <string name="busort13">The same operations are repeated until all of the numbers are fully sorted.</string>
    <string name="busort14">Now sorting is completed.</string>

    <!--strings for Intertion sort -->
    <string name="insort1">Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one
        item at a time.
    </string>
    <string name="insort2">To begin the leftmost number is considered as fully sorted</string>
    <string name="insort3">Next, from the remaining numbers the leftmost number is taken out and compare to the already
        sorted number to its left
    </string>
    <string name="insort4">If the sorted number is larger, the two numbers swap.</string>
    <string name="insort5">Here 3 > 1 so numbers swap</string>
    <string name="insort6">The number reached the left edge, so the number 1 stops moving.</string>
    <string name="insort7">Number 1 is now considered as fully sorted.</string>
    <string name="insort8">Now again the leftmost number from the remaining numbers is taken out and compared to the
        number to its left
    </string>
    <string name="insort9">In this case, 3 is less than 5 so numbers were not swapped</string>
    <string name="insort10">and 5 is considered as fully sorted.</string>
    <string name="insort11">As before, the leftmost number from the remaining numbers is taken out and compared to the
        number to its left
    </string>
    <string name="insort12">In this case, 5 is greater than 2 so numbers were swapped</string>
    <string name="insort13">3 is greater than 2 so numbers were swapped</string>
    <string name="insort14">1 is less than 2. A smaller number is appeared, so the 2 stops moving.</string>
    <string name="insort15">The 2 is now considered as fully sorted.</string>
    <string name="insort16">The same operations are repeated until all of the numbers are fully sorted.</string>
    <string name="insort17">Now sorting is completed.</string>

    <!-- heap sort -->
    <string name="hep1">Heap sort is an algorithm used to sort a sequence of numbers</string>
    <string name="hep2">At first,all the numbers are sorted in a heap. These heaps are constructed so that numbers are
        in descending order.
    </string>
    <string name="hep3">7 is greater than 5</string>
    <string name="hep4">To make heap in descending order 7 has become the root and 5 as child</string>
    <string name="hep5">All the numbers are sorted in a heap. These heaps are constructed so that numbers are in
        descending order.
    </string>
    <string name="hep6">All the numbers have to stored in heap.</string>
    <string name="hep7">Next, the numbers stored in the heap are taken out one by one.</string>
    <string name="hep8">One property of descending heap is that numbers are removed from largest to smallest, so if you line the numbers up in the opposite order from right to left as they get removed, sorting is complete.</string>
    <string name="hep9">All the numbers were removed from the heap, and sorting is complete.</string>

    <!-- Merge sort -->
    <string name="mer1">Merge sort is a sorting algorithm used to sort a sequence of numbers</string>
    <string name="mer2">First, the sequence is divided further and further into halves.</string>
    <string name="mer3">The divisions of array is completed. </string>
    <string name="mer4">Next, the divided groups are combined.</string>
    <string name="mer5">When being combined,each group\'s numbers are arranged so that they are ordered from smallest to largest after combination. </string>
    <string name="mer6">When groups with multiple numbers are combined, the first numbers are compared.</string>
    <string name="mer7">In the diagram, first numbers 2 and 3 will be compared.</string>
    <string name="mer8">3 is greater than 2, so the  2 is moved.</string>
    <string name="mer9">The remaining rows  have  their first numbers compared in the same way</string>
    <string name="mer10">3 is less than 5, so the 3 is moved.</string>
    <string name="mer11">5 and 7 will be compared.</string>
    <string name="mer12">5 is less than 7, so the 5 is moved.</string>
    <string name="mer13">The remaining 7 is moved. </string>
    <string name="mer14">The combining of groups is repeated recursively until all the numbers form one group.</string>
    <string name="mer15">Combining is complete, and the sequence has been sorted.</string>
    <string name="mer16">This concludes the explanation of merge sort.</string>

    <!-- selection sort -->
    <string name="sel1">Selection sort is one algorithm used to sort a sequence of numbers.</string>
    <string name="sel2">Using linear search, the smallest value in the  sequence is located. In this case 1 is smallest number in sequence.</string>
    <string name="sel3">The smallest value swaps with the leftmost number and is considered fully sorted</string>
    <string name="sel4">If the smallest value happens to already be in the leftmost position, no operation is carried out.</string>
    <string name="sel5">The same operations are repeated until all of the numbers are fully sorted.</string>
    <string name="sel6">Here, 5 is smallest number and located on leftmost position.</string>
    <string name="sel7">5 is the smallest number located on leftmost position. So no operation happened.</string>
    <string name="sel8">Again the same operations are repeated until all of the numbers are fully sorted.</string>
    <string name="sel9">Now sorting is completed.</string>


    <!-- linear search -->
    <string name="lin1">Linear search is an algorithm for searching through elements of an array.</string>
    <string name="lin2">Lets try searching for the number</string>
    <string name="lin3">First, we examine the leftmost number in the array.</string>
    <string name="lin4">We compare it with 9, and if it matches, the search ends. If does not match, we examine the next number to the right.</string>
    <string name="lin5">We repeat the comparisons until the 9 is found</string>
    <string name="lin6">We found the number 9, so the search ends.</string>
    <string name="lin7">Linear search is a simple technique for doing repeated comparisons in order from the beginning.</string>
    <string name="lin8">When there is a lot of data, the number of comparisons increases, and it takes more time.</string>


    <!-- binary search -->
    <string name="bin1">Binary search is an algorithm for searching through elements of a presorted array.</string>
    <string name="bin10">6 = 6, so we found the number we were looking for.</string>
    <string name="bin11">In this way, we see that binary search makes use of a presorted array and continuously halves the numbers to search through, allowing it to search for numbers efficiently.</string>
    <string name="bin2">Lets try searching for the number 6</string>
    <string name="bin3">First, we look at the number in the center of the array. In this case it\'s 5.</string>
    <string name="bin4">We compare 5 to the number 6 that we are searching for. Because 5 is less than 6, we know the number 6 is to the right of number 5.</string>
    <string name="bin5">From the candidates, we remove numbers that are no longer needed.</string>
    <string name="bin6">Again we look at the number in the the center of the remaining array. The this time it\'s number 7.</string>
    <string name="bin7">We compare 7 to 6. Because 6 is less than 7, we know that the number 6 is to the left of 7.</string>
    <string name="bin8">From the candidates, we remove numbers that are no longer needed.</string>
    <string name="bin9">We look at the number in the center of the remaining array. This time it\'s 6.</string>

    <!-- array -->
    <string name="arry1">Arrays are type of data structure and can store multiple values.</string>
    <string name="arry2">Each element can be accessed through its index.</string>
    <string name="arry3">Data is stored sequentially in memory in consecutive locations as shown above.</string>
    <string name="arry4">Because they are stored in consecutive locations, memory addresses can be calculated using their indices, allowing for random access of data.</string>
    <string name="arry5">Adding and deleting data is another feature of arrays carries a high cost compared to lists.</string>
    <string name="arry6">Lets imagine adding Green to 3rd location.</string>
    <string name="arry7">First we secure an additional space at the end of the array.</string>
    <string name="arry8">In order to free up the space needed for the addition, data is shifted one element at a time.</string>
    <string name="arry9">Green is added to the empty space, completing the addition.</string>
    <string name="arry10">When deleting the second element, we first delete the element,</string>
    <string name="arry11">then fill the empty space by shifting the data one element at a time.</string>
    <string name="arry12">Finally, the extra space is deleted, completing the deletion.</string>
    <string name="arry13">This concludes the explanation of arrays</string>

    <!-- Stack -->
    <string name="stc1">Stacks are one type of data structure.</string>
    <string name="stc2">The structure of a stack can be easily imagined as a pile of objects stacked vertically.</string>
    <string name="stc3">We use the term \"push\" to refer to the act of adding data to a stack.</string>
    <string name="stc4">We use the term \"pop\" to refer to the act of extracting data from a stack.</string>
    <string name="stc5">When adding data to a stack, the data is put into the lowest available location.</string>
    <string name="stc6">When extracting data from a stack, the most recently added data is removed first.</string>
    <string name="stc7">This method of extracting the most recently added data first is called Last in First Out, or LIFO</string>

    <!-- Queue -->
    <string name="qu1">Queues are one type of data structure.</string>
    <string name="qu2">Queues are also known as waiting lines, and as the same name suggests, they can be easily imagined as a group of people waiting in line</string>
    <string name="qu3">In queues, the sooner a person lines up, the higher their priority.</string>
    <string name="qu4">When adding data to a queue, the data is placed at the end.</string>
    <string name="qu5">We use the term \"enqueue\" to refer to the act of adding data to a queue.</string>
    <string name="qu6">We use the term \"dequeue\" to refer to the act of extracting data from a queue.</string>
    <string name="qu7">When extracting data from a queue, the data that\'s been in the queue the longest is removed first.</string>
    <string name="qu8">This method of extracting the initially added data first is called First In First Out, or FIFO for short.</string>
    <string name="qu9">This concludes the explanation of queues.</string>

    <!-- List -->
    <string name="lst1">Lists are type of data structure and can store multiple values.</string>
    <string name="lst2">They are unique in how they pair data with pointers, the pointers indicating the next piece of data\'s memory location</string>
    <string name="lst3">In lists, data is stored in various disjointed locations in memory.</string>
    <string name="lst4">Because data is stored in different locations, each piece of data can only be accessed through the pointer that precedes it.</string>
    <string name="lst5">Addition of data is performed simply by replacing the pointers on either side of the addition.</string>
    <string name="lst6">To add new node at second position in list first create new node and create link with second node.</string>
    <string name="lst7">Head is linked with the node adding in list.</string>
    <string name="lst8">We are going to delete 1st node from the above list. Firstly, we will point the 2nd node as head.</string>
    <string name="lst9">Now delete the node.</string>
    <string name="lst10">This concludes the explanation of lists.</string>
    <!-- heap -->
    <string name="hp1">Heaps are one type of tree data structure, and are used when implementing a priority queue.</string>
    <string name="hp10">This operation is repeated until no additional swaps occur.</string>
    <string name="hp11">the parent 1 is less than the child 5, so since the parent is smaller,no swap occurs.</string>
    <string name="hp12">The addition of number 5 is now completed.</string>
    <string name="hp13">When extracting a number from a heap, the number on the top is removed.</string>
    <string name="hp14">In a heap, the smallest value is held in the top location.</string>
    <string name="hp15">Because the top number was removed, the heap\'s structure needs to be reorganized.</string>
    <string name="hp16">The number at the end of the line moves to the top.</string>
    <string name="hp17">When one of the child number is less than the parent, the lowest of the adjacent child numbers swap with the parent.</string>
    <string name="hp18">The parent 6 was greater than the child to the right 5 which was in turn greater than the child to the left 3, so the left child and parent swapped.</string>
    <string name="hp19">The right child 8 was greater than the parent 6 which was in turn greater than the child to the left 4, so the left child and parent swapped.</string>
    <string name="hp2">A priority queue is one type of data structure.</string>
    <string name="hp20">The extraction of a number from the heap is now completed.</string>
    <string name="hp21">In this way, heaps can be used to quickly extract the smallest data.</string>
    <string name="hp22">However, extraction of data in the middle of the tree cannot be performed.</string>
    <string name="hp23">This concludes the explanation of heaps..</string>
    <string name="hp3">In a priority queue, data can be added in any order.</string>
    <string name="hp4">Conversely, when extracting data, the smallest values are chosen first.Being able to freely add data and then extract the smallest values first defines a priority queue.</string>
    <string name="hp5">As a rule of heaps, a child number is always greater than its parent number.</string>
    <string name="hp6">Let\'s try adding a number to the heap.</string>
    <string name="hp7">The number that\'s added is first placed onto the end of the line.</string>
    <string name="hp8">If the parent number happens to be greater, the child and parent swaps.</string>
    <string name="hp9">Since the parent 6 is greater than the child 5 the two numbers swap.</string>

    <!-- Binary search tree -->
    <string name="bst1">Binary search trees are one type of data structure.</string>
    <string name="bst2">The numbered points are called nodes.</string>
    <string name="bst3">Binary search trees have two properties.</string>
    <string name="bst4">Their first property is that all nodes are greater than the nodes in their left subtree.</string>
    <string name="bst5">For example, node 3 is greater than the other number in its left subbste.</string>
    <string name="bst6">Likewise, node 8 is greater than the other numbers in its left subbste.</string>
    <string name="bst7">On the contrary, their second property is that all nodes are smaller than the nodes in their right subbste.</string>
    <string name="bst8">For example, node 8 is smaller than the other numbers in its right subtree.</string>
    <string name="bst9">Because of these two properties, this tree holds true.</string>
    <string name="bst10">Let\'s take a look at the process of adding nodes to a binary search tree.</string>
    <string name="bst11">As an example, we\'ll try adding a 2.</string>
    <string name="bst12">We start at the topmost node of the binary search tree in order to find the additional nodes\'s proper location..</string>
    <string name="bst13">2 is less than 8, so it proceeds to left.</string>
    <string name="bst14">2 is less than 3, so it proceeds to left.</string>
    <string name="bst15">2 is greater than 1, so it proceeds to right, but since there isn\'t node to move to, the 2 is added as a new node.</string>
    <string name="bst16">The addition of the 2 is now completed.</string>
    <string name="bst17">Now let\'s look at the process for deleting nodes from binary search bste.</string>
    <string name="bst18">Let\'s try deleting the 13.</string>
    <string name="bst19">When the node has no children, the target node is simply deleted and the process is completed.</string>
    <string name="bst20">Let\'s try deleting the 6.</string>
    <string name="bst21">When deleting a node that has two children..</string>
    <string name="bst22">first we delete the target node..</string>
    <string name="bst23">and from the deleted node\'s children 7 is largest move it to the deleted node\'s location.</string>
    <string name="bst24">Let\'s try deleting the 6.</string>
    <string name="bst25">When deleting a node that has two children first we delete the target node.</string>
    <string name="bst26">and from the deleted node\'s left subbste we find the largest node..</string>
    <string name="bst27">and move it to the deleted node\'s location.</string>
    <string name="bst28">By doing this, we were able to delete a node while preserving the integrity of the binary search bste.</string>
    <string name="bst29">Furthermore, if the node that was removed also had its own child nodes, the same process is repeated recursively.</string>
    <string name="bst30">Also, while we used the largest node from the left subbtree this time, using the smallest node from the right subbste works as well.</string>
    <string name="bst31">As an example, let\'s try searching for the 14.</string>
    <string name="bst32">We start our search at the topmost node the binary search bste.</string>
    <string name="bst33">14 is greater than 8, so we proceed to the right.</string>
    <string name="bst34">14 is greater than 10, so we proceed to the right.</string>
    <string name="bst35">We found the 14.</string>
    <string name="bst36">As you can see, we are able to search efficiently using binary search bste.</string>
    <string name="bst37">However, if the bste gets close to forming a straight line, its search efficiency becomes exbstmely poor, like a linear search.</string>
    <string name="bst38">On the other hand, binary search bste that are always well-balanced, called self-balancing\10        binary search bste, are able to maintain search efficiency.</string>
    <string name="bst39">This concludes the explanation of binary search bstes.</string>
</resources>
